接口设计模式：

6大原则：
1.开闭原则(Open - ClosedPrinciple ,OCP)
定义：一个模块、类、函数应当是对修改关闭，扩展开放。即软件实体应尽量在不修改原有代码的情况下进行扩展
修改原有的代码可能会导致原本正常的功能出现问题。
因此，当需求有变化时，最好是通过扩展来实现，增加新的方法满足需求，而不是去修改原有代码。
2.单一职责原则（Single Responsibility Principle, SRP）
定义：每个类应该实现单一的职责，否则应该把类拆分。
一个类职责过大的话，首先引起的问题就是这个类比较大，显得过于臃肿，同时其复用性是比较差的。
其次就是如果修改某个职责，有可能引起另一个职责发生错误。这是我们极力所避免的，因此设计一个类时我们应当去遵循单一职责原则。
3.里氏替换原则( Liskov Substitution Principle ,LSP )
定义：使用父类的地方能够使用子类来替换；子类的所有方法必须在父类中声明。
使用子类对象去替换父类对象，程序将不会产生错误
因此在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象。
需要注意的是：
子类的所有方法必须在父类中声明，或子类必须实现父类中声明的所有方法。根据里氏代换原则，为了保证系统的扩展性，在程序中通常使用父类来进行定义，如果一个方法只存在子类中，在父类中不提供相应的声明，则无法在以父类定义的对象中使用该方法。
父类应当被尽量设计为抽象类或者接口，让子类继承父类或实现父接口，并实现在父类中声明的方法，运行时，子类实例替换父类实例，我们可以很方便地扩展系统的功能，同时无须修改原有子类的代码，增加新的功能可以通过增加一个新的子类来实现
子类必须实现父类的抽象方法，但不得重写（覆盖）父类的非抽象（已实现）方法。
子类中可以增加自己特有的方法。
当子类重载父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松。
当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。
4.依赖倒置原则( Dependence Inversion Principle ,DIP )
定义：这是开闭原则的基础，对接口编程，依赖于抽象而不依赖于具体。
高层模块不应该依赖低层模块，应该去依赖抽象。
抽象不应该依赖细节
细节应该依赖抽象
5.接口隔离法则(Interface Segregation Principle，ISL）
定义：一个类对另一个类的依赖应该建立在最小的接口上。
一个类不应该依赖他不需要的接口。每个接口不存在子类用不到却必须实现的方法，否则要将接口拆分。
接口的粒度要尽可能小，如果一个接口的方法过多，可以拆成多个接口。
6.迪米特法则(Law of Demeter, LoD)
定义：又叫作最少知识原则；一个类尽量不要与其他类发生关系
一个类对其他类知道的越少，耦合越小。
当修改一个类时，其他类的影响就越小，发生错误的可能性就越小。

常用设计模式：
1、创建性模式：
单例模式、工厂模式、抽象工厂模式、建造者模式、原型模式
2、结构型模式：
适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式，代理模式
3、行为型模式：
模板方法模式、命令模式、迭代器模式、观察者模式、中介者模式、备忘录模式、接解释器模式、状态模式、策略模式、职责链模式、访问者模式。


1）工厂模式：
在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。

简单工厂模式：
抽象产品：定义了产品的规范，描述了产品的主要特性和功能。
具体产品：实现或者继承抽象产品的子类。
具体工厂：提供了创建产品的方法，使用者通过该方法来获取产品。

工厂方法模式(Factory Method)：
和简单工厂模式中工厂负责生产所有产品相比，工厂方法模式将生成具体产品的任务分发给具体的产品工厂

抽象工厂模式：
使用 抽象工厂来管理所有的工厂

2）单例模式：
单例模式是指在内存中只会创建且仅创建一次对象的设计模式。

单例模式实现步骤：
1、将该类的构造方法定义为私有方法，这样其他处的代码就无法通过调用该类的构造方法来实例化该类的对象，只有通过该类提供的静态方法来得到该类的唯一实例；
2、在该类内提供一个静态方法，当我们调用这个方法时，如果类持有的引用不为空就返回这个引用，如果类保持的引用为空就创建该类的实例并将实例的引用赋予该类保持的引用。

饿汉式：在类加载时已经创建好该单例对象，等待被程序使用

懒汉式：在真正需要使用对象时才去创建该单例类对象
双重检查加锁

单元素的枚举实现：防反射、防止反序列化创建多个枚举对象

静态内部类

指令重排序是指：JVM在保证最终结果正确的情况下，可以不按照程序编码的顺序执行语句，尽可能提高程序的性能
使用volatile关键字可以防止指令重排序，使用volatile关键字修饰的变量，可以保证其内存可见性，即每一时刻线程读取到该变量的值都是内存中最新的那个值，线程每次操作该变量都需要先读取该变量。

破坏懒汉式单例与饿汉式单例：
无论是完美的懒汉式还是饿汉式，终究敌不过反射和序列化，它们俩都可以把单例对象破坏掉（产生多个对象）。

3）策略模式：
策略模式属于对象的行为模式。其用意是针对一组算法，将每一个算法封装到具有共同接口的独立的类中，从而使得它们可以相互替换。策略模式使得算法可以在不影响到客户端的情况下发生变化。
主要解决：在有多种算法相似的情况下，使用 if...else 所带来的复杂和难以维护。
策略模式包含三个角色：
环境Context: 持有一个抽象策略Strategy的引用
抽象策略Strategy: 抽象角色.给出所有具体策略类所需的接口,通常是由一个接口或者抽象类实现
具体策略ConcreteStrategy: 具体策略类. 封装了具体的算法
策略工厂模式：
使用hashmap，每一个策略对标一个key，具体策略作为value。

4）代理模式：
代理类与委托类有同样的接口，代理类主要负责为委托类预处理消息、过滤消息、把消息转发给委托类，以及事后处理消息等。
代理模式最主要的就是有一个公共接口（Person），一个具体的类（Student），一个代理类（StudentsProxy），代理类持有具体类的实例，代为执行具体类实例方法。
最直白的就是在Spring中的面向切面编程（AOP），我们能在一个切点之前执行一些操作，在一个切点之后执行一些操作，这个切点就是一个个方法。

静态代理：
在编译时就已经将接口、被代理类、代理类等确定下来

动态代理：
代理类在程序运行时创建的代理方式被称为动态代理。
相比于静态代理，动态代理的优势在于可以很方便的对代理类的函数进行统一的处理，而不用修改每个代理类中的方法。
在java的java.lang.reflect包下提供了一个Proxy类和一个InvocationHandler接口，通过这个类和这个接口可以生成JDK动态代理类和动态代理对象。

原理：
实现方式比较常用的是jdk动态代理和cglib动态代理。

jdk实现动态代理：
基于jdk的动态代理是必须基于接口才可以的
整个动态代理类的生成过程可以归纳为：
1.根据接口信息，新生成一个代理类的.java文件
2.根据.java，编译生成.class文件
3.classloader读取class文件信息到jvm
4.新建对象，设置InvocationHandler参数。

cglib实现动态代理：
cglib的代理实现不需要基于接口。cglib是针对类来实现代理的,它的原理是对指定的目标类生成一个子类，并覆盖其中方法实现增强,因为采用的是继承，所以不能对final修饰的类进行代理

JDK和CGLIB动态代理的区别:
1）JDK代理使用的是反射机制生成一个实现代理接口的匿名类，在调用具体方法前调用InvokeHandler来处理。
CGLIB代理使用字节码处理框架asm，对代理对象类的class文件加载进来，通过修改字节码生成子类。
2）JDK创建代理对象效率较高，执行效率较低；
CGLIB创建代理对象效率较低，执行效率高。
3）JDK动态代理机制是委托机制，只能对实现接口的类生成代理，通过反射动态实现接口类；
CGLIB则使用的继承机制，针对类实现代理，被代理类和代理类是继承关系，所以代理类是可以赋值给被代理类的，因为是继承机制，不能代理final修饰的类。
4）JDK代理是不需要依赖第三方的库，只要JDK环境就可以进行代理，需要满足以下要求：
实现InvocationHandler接口，重写invoke()
使用Proxy.newProxyInstance()产生代理对象
被代理的对象必须要实现接口
CGLib 必须依赖于CGLib的类库,需要满足以下要求：
实现MethodInterceptor接口，重写intercept()
使用Enhancer对象.create()产生代理对象

5）观察者模式：
（又被称为发布-订阅（Publish/Subscribe）模式，属于行为型模式的一种，它定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态变化时，会通知所有的观察者对象，使他们能够自动更新自己。

在观察者模式中有如下角色：
Subject：抽象主题（抽象被观察者），抽象主题角色把所有观察者对象保存在一个集合里，每个主题都可以有任意数量的观察者，抽象主题提供一个接口，可以增加和删除观察者对象。
ConcreteSubject：具体主题（具体被观察者），该角色将有关状态存入具体观察者对象，在具体主题的内部状态发生改变时，给所有注册过的观察者发送通知。
Observer：抽象观察者，是观察者的抽象类，它定义了一个更新接口，使得在得到主题更改通知时更新自己。
ConcrereObserver：具体观察者，实现抽象观察者定义的更新接口，以便在得到主题更改通知时更新自身的状态。

使用观察者模式的场景和优缺点：
使用场景：
关联行为场景，需要注意的是，关联行为是可拆分的，而不是“组合”关系。
事件多级触发场景。
跨系统的消息交换场景，如消息队列、事件总线的处理机制。
优点：
解除耦合，让耦合的双方都依赖于抽象，从而使得各自的变换都不会影响另一边的变换。
缺点：
在应用观察者模式时需要考虑一下开发效率和运行效率的问题，程序中包括一个被观察者、多个观察者，开发、调试等内容会比较复杂，而且在Java中消息的通知一般是顺序执行，那么一个观察者卡顿，会影响整体的执行效率，在这种情况下，一般会采用异步实现。


