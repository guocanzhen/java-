面试点：

4、线程

线程与进程的关系
1、线程：每个进程中至少包含一个线程，而这些线程都在共享进程的资源空间等，当线程发生变化的时候只会引起CPU执行的过程发生变化，不会改变进程所拥有的资源。同理一个程序中至少包含一个进程。进程中执行运算的最小单位，亦是执行处理机调度的基本单位
2、进程：每个进程都有自己的地址空间，资源如，内存，I/O,CPU，同一个进程里的线程共享本进程里的地址空间，那能不能使用别人家进程的地址空间呢，显然这是不可以的。由于进程的独立性，当某一个进程崩溃之后，在保护模式下不会对别的进程进行影响。资源分配的基本单位，运行调度的基本单位，系统中并发执行的单位。
3、使用区别：当我们对资源的保护管理要求比较高的时候，建议使用多进程，当然存在的开销也会比较大，反过来，如果频繁切换下，对资源的保护管理要求不那么高，或者开销有限，使用多线程会比较方便。
4、两者的比较：
（1）调度
同一个进程中，线程的切换不会引起进程的切换；
由一个进程的线程切换到另一个进程的线程时，引起进程的切换。
（2）并发性
进程可以并发执行，而一个进程中的线程也可以并发执行
（3）拥有的资源
一般来说，线程并不会拥有自己的资源，但是它可以访问自己本进程中的资源，比如，一个进程打开的文件等，进程的其他线程是可以共享的。
（4）系统开销

多线程
创建：
1、继承Thread类：重写run方法，运行：Thread.start
2、实现Runnable接口：重写run方法，运行：Thread.start
3、实现Callable接口：重写call方法，运行：Thread.start
Callable和Runnable的区别：
callable的核心是call方法，允许返回值，runnable的核心是run方法，没有返回值
call方法可以抛出异常，但是run方法不行
因为runnable是java1.1就有了，所以他不存在返回值，后期在java1.5进行了优化，就出现了callable，就有了返回值和抛异常
callable和runnable都可以应用于executors。而thread类只支持runnable

4、线程池
线程池，参数及其作用
1、核心线程数：线程池中会维护一个最小的线程数量，即使这些线程处理空闲状态，他们也不会被销毁，除非设置了allowCoreThreadTimeOut。这里的最小线程数量即是corePoolSize。任务提交到线程池后，首先会检查当前线程数是否达到了corePoolSize，如果没有达到的话，则会创建一个新线程来处理这个任务。
2、最大线程数：当前线程数达到corePoolSize后，如果继续有任务被提交到线程池，会将任务缓存到工作队列（后面会介绍）中。如果队列也已满，则会去创建一个新线程来出来这个处理。线程池不会无限制的去创建新线程，它会有一个最大线程数量的限制，这个数量即由maximunPoolSize指定。
3、工作队列、队列大小：新任务被提交后，会先进入到此工作队列中，任务调度时再从队列中取出任务。
①ArrayBlockingQueue：基于数组的有界阻塞队列，按FIFO排序。新任务进来后，会放到该队列的队尾，有界的数组可以防止资源耗尽问题。当线程池中线程数量达到corePoolSize后，再有新任务进来，则会将任务放入该队列的队尾，等待被调度。如果队列已经是满的，则创建一个新线程，如果线程数量已经达到maxPoolSize，则会执行拒绝策略。
②LinkedBlockingQuene：基于链表的无界阻塞队列（其实最大容量为Interger.MAX），按照FIFO排序。由于该队列的近似无界性，当线程池中线程数量达到corePoolSize后，再有新任务进来，会一直存入该队列，而基本不会去创建新线程直到maxPoolSize（很难达到Interger.MAX这个数），因此使用该工作队列时，参数maxPoolSize其实是不起作用的。
③SynchronousQuene：一个不缓存任务的阻塞队列，生产者放入一个任务必须等到消费者取出这个任务。也就是说新任务进来时，不会缓存，而是直接被调度执行该任务，如果没有可用线程，则创建新线程，如果线程数量达到maxPoolSize，则执行拒绝策略。
④PriorityBlockingQueue：具有优先级的无界阻塞队列，优先级通过参数Comparator实现。
4、空闲线程活跃时间：一个线程如果处于空闲状态，并且当前的线程数量大于corePoolSize，那么在指定时间后，这个空闲线程会被销毁，这里的指定时间由keepAliveTime来设定
5、空闲线程活跃时间单位
6、默认线程名称、线程工厂
7、拒绝策略
丢弃策略DiscardPolicy：对新的任务不做任何处理，翻译过来就是丢弃策略，业务中慎用。
中止策略AbortPolicy：抛出了RejectedExecutionException异常，会对代码的运行进行中止，默认拒绝策略，不执行新任务抛出异常
优先处理策略CallerRunsPolicy：把新任务交给主线程来执行，对新的任务进行优先执行，直接调用其run方法
丢弃最老任务DiscardOldestPolicy：拿到队列，调用队列的poll方法对队列中最老的任务进行丢弃，再将新的任务放入队列中
自定义拒绝策略：重写rejectedExecution方法，可以写到日志里面，也可以存储到数据库 ，也可以啥也不做


5、事务：
@Transactional原理：AOP动态代理

@Transactional事务嵌套：
1、两个方法在同一个类中：同一个类中子方法上的@Transactional注解是不生效的，都是取决于主方法有没有事务。
@Transactional事务是Spring采用动态代理(AOP)来实现的，为我们的每个类生成一个代理对象。只有在代理对象之间进行调用时，可以触发AOP。
而在同一个类中，主方法调用子方法，调用的是原对象的方法，而不通过代理对象。所以Spring无法切到这次调用，也就无法通过注解保证事务性了。也就是说，在同一个类中的方法调用，则不会被方法拦截器拦截到，因此事务不会起作用。
2、当两个方法不再同一个类中，把子方法注入（@Autowried）到主方法中：
主有子有：有
注：
子为propagation = Propagation.REQUIRES_NEW（新的事务），如果子回滚，主回滚。如果主回滚，子不回滚。
主有子无：有
主无子有：子有

事务失效：
1、@Transactional 注解只能应用到 public 可见度的方法上。
如果应用在protected、private或者 package可见度的方法上，也不会报错，不过事务设置不会起作用。
2、默认情况下，Spring会对Error或者RuntimeException异常进行事务回滚，
其他继承自java.lang.Exception的异常：如IOException、TimeoutException等，不会回滚。
解决方案：Transactional注解加 rollbackFor 属性，指定java.lang.Exception.class;
3、try-catch异常，事务不会生效
spring的事务是在调用业务方法之前开始的，业务方法执行完毕之后才执行commit or rollback，
事务是否执行取决于是否抛出runtime异常。如果抛出runtime exception 并在你的业务方法中没有catch到的话，事务会回滚。
4、@Transactional 注解属性 propagation 设置错误
TransactionDefinition.PROPAGATION_NOT_SUPPORTED：以非事务方式运行，如果当前存在事务，则把当前事务挂起。
TransactionDefinition.PROPAGATION_NEVER：以非事务方式运行，如果当前存在事务，则抛出异常。
5、同一个类中方法调用，导致@Transactional失效
场景：开发中避免不了会对同一个类里面的方法调用，比如有一个类Test，它的一个方法A，A再调用本类的方法B
（不论方法B是用public还是private修饰），但方法A没有声明注解事务，而B方法有。则外部调用方法A之后，
方法B的事务是不会起作用的。
原因：由于使用Spring AOP代理造成的，因为只有当事务方法被当前类以外的代码调用时，才会由Spring生成的代理对象来管理。
6、数据库引擎不支持事务。


6、类
类的生命周期：
加载、链接、初始化、使用、卸载
链接：验证、准备、解析
1、加载：将java类的字节码文件加载到机器内存中，并在内存中构建出java类的原型（类模板对象）
a、加载类时，java虚拟机加载步骤
（1）通过类的全名，获取类的二进制数据流
（2）解析类的二进制数据流为方法区内的数据结构（Java类模型）
（3）创建java.lang.Class类的实例，作为方法区这个类的各种数据的访问入口
b、类模型和Class实例的位置
（1）类模型存储在方法区
（2）class文件加载到元空间后，会在堆中创建一个Class对象，用来封装类位于方法区内的数据结构。每一个类都对应一个Class对象
c、数组类的加载
数组类本身并不是由类加载器负责创建，而是由jvm在运行时根据需要直接创建的，但是数组的元素类型仍然需要依靠类加载器去创建。创建步骤如下
（1）如果数组的元素类型是引用类型，那么遵循定义的加载过程递归加载和创建数组A的元素类型
（2）jvm使用指定的元素类型和数组维度类创建新的数组类。
2、验证
保证加载的字节码是合法的。
验证通过之后类加载器才会将类的二进制数据加载到方法区中，除格式验证之外的验证操作是在方法区中进行
（1）格式验证
（2）语义检查
（3）字节码验证
（4）符号引用验证
3、准备
当一个类通过验证，就会进入准备阶段，为静态变量分配内存，并初始化默认值。
java不支持boolean类型，内部实现是int，由于int默认值为0，所以boolean的默认值为false.
4、解析
将接口，字段和方法的符号引用转换为直接引用。
java虚拟机为每一个类都准备一张方法表，将其所有的方法列在其中，当需要调用一个类的方法时，只要知道这个方法在方法表的偏移量（通过解析操作，符号引用转换为直接引用类中的方法表中的位置），就可以直接调用该方法了。
不过java虚拟机规范并没有明确要求解析阶段一定要按序执行，在hotspot中，按照加载，验证，准备和初始化的顺序执行，但链接阶段的解析操作往往伴随着jvm执行完初始化之后再执行。
4、初始化
类的初始化是类装载的最后一个阶段，也是真正开始执行类定义的java的程序代码<clinit>()方法
在加载一个类之前会先加载其父类，因此父类的<clinit>方法总是在子类<clinit>方法之前被调用。
（1）使用static+final修饰，且显示赋值中不涉及到方法或者构造器调用的基本数据类型或者String类型的显示赋值，是在链接阶段的准备环节进行赋值。
（2）<clinit>线程安全性
5、使用
6、卸载
如果有下面的情况，类就会被卸载：
（1）该类所有的实例都已经被回收，也就是java堆中不存在该类的任何实例。
（2）加载该类的ClassLoader已经被回收。
（3）该类对应的java.lang.Class对象没有任何地方被引用，无法在任何地方通过反射访问该类的方法。
如果以上三个条件全部满足，jvm就会在方法区垃圾回收的时候对类进行卸载，类的卸载过程其实就是在方法区中清空类信息，java类的整个生命周期就结束了。

对象的生命周期：
1、创建阶段：
为对象分配存储空间，构造对象
2、应用阶段：
对象至少被一个强引用持有着。
3、不可见阶段：
当一个对象处于不可见阶段时，说明程序本身不再持有该对象的不论什么强引用，尽管该这些引用仍然是存在着的。
简单说就是程序的运行已经超出了该对象的作用域了。
4、不可达阶段：
对象处于不可达阶段是指该对象不再被不论什么强引用所持有。
5、收集阶段：
当垃圾回收器发现该对象已经处于“不可达阶段”而且垃圾回收器已经对该对象的内存空间又一次分配做好准备时，则对象进入了“收集阶段”。假设该对象已经重写了finalize()方法，则会去运行该方法的终端操作。
这里要特别说明一下：不要重载finalize()方法！原因有两点：
会影响JVM的对象分配与回收速度
在分配该对象时，JVM须要在垃圾回收器上注冊该对象，以便在回收时可以运行该重载方法；在该方法的运行时须要消耗CPU时间且在运行完该方法后才会又一次运行回收操作，即至少须要垃圾回收器对该对象运行两次GC。
可能造成该对象的再次“复活”
6、终结阶段：
当对象运行完finalize()方法后仍然处于不可达状态时，则该对象进入终结阶段。在该阶段是等待垃圾回收器对该对象空间进行回收。
7、对象空间又一次分配阶段（释放阶段）
垃圾回收器对该对象的所占用的内存空间进行回收或者再分配了，则该对象彻底消失了，称之为“对象空间又一次分配阶段”。


7、反射
Java 反射，就是在运行状态中
1、获取任意类的名称、package信息、所有属性、方法、注解、类型、类加载器等
2、获取任意对象的属性，并且能改变对象的属性
3、调用任意对象的方法
4、判断任意一个对象所属的类
5、实例化任意一个类的对象
Java 的动态就体现在这。通过反射我们可以实现动态装配，降低代码的耦合度；动态代理等。反射的过度使用会严重消耗系统资源。


9、rpc
远程过程调用协议RPC（Remote Procedure Call Protocol)-----允许像调用本地服务一样调用远程服务。
由于不在一个内存空间，不能直接调用，需要通过网络来表达调用的语义和传达调用的数据。
1、远程服务之间建立通讯协议
2、寻址：服务器（如主机或IP地址）以及特定的端口，方法的名称是什么
3、通过序列化和反序列化进行数据传递
4、将传递过来的数据通过java反射原理定位接口方法和参数
5、暴露服务：用map将寻址的信息暴露给远方服务（提供一个endpoint URI或者一个前端展示页面）
6、多线程并发请求业务


10、dubbo
高性能、轻量级的开源Java RPC框架，它提供了三大核心能力：面向接口的远程方法调用，智能容错和负载均衡，以及服务自动注册和发现。


12、跨域
定义：当一个请求url的协议、域名、端口三者之间任意一个与当前页面url不同即为跨域。
跨域问题来源于JavaScript的同源策略，即只有 协议+主机名+端口号(如存在)相同，则允许相互访问。也就是说JavaScript只能访问和操作自己域下的资源，不能访问和操作其他域下的资源。跨域问题是针对JS和ajax的，html本身没有跨域问题，比如a标签、script标签、甚至form标签（可以直接跨域发送数据并接收数据）等


13、集合

iterator迭代器

Collections.synchronizedSet或Collections.synchronizedList或Collections.synchronizedMap将集合包装成线程安全集合。

List：Arraylist、LinkedList、Vector
Arraylist：底层数据结构是数组，查询快，增删慢，线程不安全，效率高，可以存储重复元素
动态数组，存储引用对象地址，指向堆对象
初始容量是10，扩容会按之前的1.5倍进行扩容，通过数组复制
通过数组索引，速度快
需要预留一定存储空间

LinkedList：底层数据结构是双向链表，增删快，线程不安全，可以存储重复元素
LinkedList是线性的数据存储方式，所以需要移动指针从前往后依次查找。
LinkedList主要控件开销在于需要存储节点信息以及节点指针。

Vector：底层数据结构是动态数组
初始容量10，可以手动设置扩容大小，设置为0时按之前的2倍进行扩容，
Vector与ArrayList的实现方式非常相似，但是ArrayList中的方法没有synchronized关键字修饰，而Vector类中的方法都有synchronized关键字修饰，其中的单个方法都属于原子操作，是线程安全的。
注意：多个原子操作组成的复合操作并不是线程安全的，必须将该复合操作变成原子操作，才能保证线程安全。
然而正因为Vector类中每个方法中都添加了synchronized的关键字来保证同步，使得它的效率大大的降低了，比ArrayList的效率要慢，因此一般情况下都不使用Vector对象，而会选择使用ArrayList。

Set：HashSet、LinkedHashSet、TreeSet
HashSet：由HashMap实现的，不保证元素的顺序，而且HashSet允许使用 null 元素。

Map：HashMap、HashTable、TreeMap、LinkedHashMap、IdentityHashMap、WeakHashMap
HashMap：数组+(链表或红黑树)
jdk1.7采用数组+链表，jdk1.8采用数组+(链表或红黑树)，如果链表长度大于8且节点数组长度大于等于64的时候，就把链表下所有的节点转为红黑树。否则继续采用扩容策略
hashcode，该值用来定位要将这个元素存放到数组中的什么位置
通过hashcode值和数组长度取模我们可以得到元素存储的下标。
1、数组索引为1的地方是空的，这种情况很简单，直接将元素放进去就好了。
2、已经有元素占据了索引为1的位置，这种情况下我们需要判断一下该位置的元素和当前元素是否相等，如果两者相等则直接覆盖，如果不等则在原元素下面使用链表的结构存储该元素。
每个元素节点都有一个next属性指向下一个节点，这里由数组结构变成了数组+链表结构
因为链表中元素太多的时候会影响查找效率，所以当链表的元素个数达到8的时候使用链表存储就转变成了使用红黑树存储，原因就是红黑树是平衡二叉树，在查找性能方面比链表要高。
初始容量大小是创建时给数组分配的容量大小，默认值为16（哈希碰撞，均匀分布）。加载因子默认0.75f，用数组容量大小乘以加载因子得到一个值，一旦数组中存储的元素个数超过该值就会调用rehash方法将数组容量增加到原来的两倍，专业术语叫做扩容。
在做扩容的时候会生成一个新的数组，原来的所有数据需要重新计算哈希码值重新分配到新的数组，所以扩容的操作非常消耗性能。
非线程安全的

线程安全的集合
Vector相当于 ArrayList 的翻版，是长度可变的数组，Vector的每个方法都加了 synchronized 修饰符，是线程安全的。
Hashtable是一个线程安全的集合,是单线程集合，它给几乎所有public方法都加上了synchronized关键字。这相当于给整个哈希表加了一把大锁。
Stack继承于Vector， 栈是后进先出的。
ArrayBlockingQueue是一个阻塞队列,底层使用数组结构实现,按照先进先出(FIFO)的原则对元素进行排序。
ConcurrentHashMap jdk1.7采用了分段锁(Segment，针对数据操作加锁)，jdk1.8采用node，针对数组加锁，HashTable的加锁方法是给每个方法加上synchronized关键字，线程安全。
ConcurrentLinkedQueue是一种FIFO的无界队列，是线程安全的，它适用于“高并发”的场景。


14、泛型
早期的Object类型可以接收任意的对象类型，但是在实际的使用中，在运行阶段会有类型转换的问题。也就存在这隐患，所以Java提供了泛型来解决这个安全问题。
泛型：是一种把明确类型的工作推迟到创建对象或者调用方法的时候才去明确的特殊的类型。也就是说在泛型使用过程中，操作的数据类型被指定为一个参数，而这种参数类型可以用在类、方法和接口中，分别被称为泛型类、泛型方法、泛型接口。
1、泛型类：在创建对象的时候确定泛型。
2、泛型方法：是在调用方法的时候指明泛型的具体类型 。
3、泛型接口：泛型接口常被用在各种类的生产器中。
定义类时确定泛型的类型
始终不确定泛型的类型，直到创建对象时，确定泛型的类型
4、泛型通配符：不知道使用什么类型来接收的时候,此时可以使用?,?表示未知通配符。
注意：泛型不存在继承、多态关系,泛型左右两边要一样
5、通配符高级使用
JAVA的泛型中可以指定一个泛型的上限和下限。
上限：类型名称 <? extends 类 > 对象名称  -- 只能接收该类型及其子类
下限：类型名称 <? super 类 > 对象名称 -- 只能接收该类型及其父类型


16、JVM调优
任何语言“编译”成class都可以用jvm。
JRE = jvm + core lib
JDK = jre + development kit
1、类加载：类加载+链接+初始化，其中链接：验证+准备+解析
2、类加载器
（1）双亲委派机制：加载类过程：加载器看自己的缓存里有没有加载过，没有则在问父加载器缓存中是否有…如果到bootstrap中都没有，则自顶向下尝试加载。如果最后谁都没加载，则抛出异常：ClassNotFoundException。使用双亲委派机制是为了安全。
（2）lazyloading：懒加载，大多数jvm都是使用该类是才初始化。JVM规范没有规定何时加载。
但是严格规定了什么时候必须初始化:
new getstatic putstatic invokestatic指令，访问final变量除外
java.lang.reflect对类进行反射调用时
初始化子类的时候，父类首先初始化
虚拟机启动时，被执行的主类必须初始化
动态语言支持java.lang.invoke.MethodHandle解析的结果为REF_getstatic REF_putstatic REF_invokestatic的方法句柄时，该类必须初始化


17、拦截器
1、自定义拦截器
自定义的拦截器可以实现HandlerInterceptor接口，也可以继承HandlerInterceptorAdapter类。
重写三个方法，当然也可以只实现一个最重要的preHandle方法。
preHandle方法：此方法会在进入controller之前执行，返回Boolean值决定是否执行后续操作。
postHandle方法：此方法将在controller执行之后执行，但是视图还没有解析，可向ModelAndView中添加数据(前后端不分离的)。
afterCompletion方法：该方法会在整个请求结束（请求结束，但是并未返回结果给客户端）之后执行， 可获取响应数据及异常信息。


18、序列化，反序列化
1、
Java 序列化是指：将对象转化成一个字节序列(二进制数据)的过程。
Java 反序列化是指：将一个对象的字节序列恢复成 Java 对象的过程。
2、核心类与关键字总览
ObjectOutputStream：IO 类，包含序列化对象的方法，writeObject()
ObjectInputStream：IO 类，包含反序列化对象的方法，readObject()
Serializable ，接口，是一个标志性接口，表示可以在 JVM 中进行序列化，JVM 会为该类自动生成一个序列化版本号。参与序列化与反序列化的类必须实现 Serializable 接口。
serialVersionUID，类属性，序列化版本号，用于给 JVM 区别同名类，没有提供版本号，JVM会默认提供序列化版本号。
transient，关键字，当序列化时，不希望某些属性参与，则可以使用这个关键字标注该属性。
3、序列化与反序列化的过程
内存中的数据信息被拆分成一小块一小块的部分，为每个小块设置编号，然后存放到硬盘文件中，也就是将 Java 对象的状态保存下来存储到文件中的过程就叫做序列化。
将硬盘中保存了 Java 对象状态的字节序列按照编号组装成对象恢复到内存中，这个过程称为反序列化。
4、序列化版本号的作用 serialVersionUID
JVM首先会通过类名来区分Java类，类名不同，则不是同一个类。当类名相同时，JVM就会通过序列化版本号来区分Java类，如果序列化版本号相同就为同一个类，序列化版本号不同就为不同的类。
在序列化一个对象时，如果没有指定序列化版本号，后期对该类的源码进行修改并重新编译后，会导致修改前后的序列化版本号不一致，因为 JVM 会提供一个新的序列化版本号给该类对象。
此时再用以往的反序列化代码去反序列化该类的对象，就会抛出异常 java.io.InvalidClassException ，所以序列化一个类时最好指定一个序列化版本号，或者永远不修改此类。
由 JVM 提供序列化版本号的好处是，同名却不同功能的类，会有两个不同的序列化版本号，JVM 可以通过序列化版本号加以区分，缺点是一旦修改源码，会重新提供序列化版本号，导致修改前后的序列化版本号不一致，进行反序列化时会出现运行时异常
由 开发人员 手动提供序列化版本号的好处是，当修改了被序列化类的源码后，以往写的反序列化代码依然可以使用，如 JDK 中的 String 类。以便后期进行增强和维护不会影响使用。
5、transient 关键字
这个关键字表示游离的，不参与序列化的。
在序列化一个对象时，如果不希望某个属性参加序列化，可以使用 transient 修饰该属性。
被该关键字修饰的属性不会参与到序列化中。
如上类，在序列化时就不会保存 age 属性，在反序列化时就不能会付出该属性，默认恢复成 null 或 0 ，由属性类型决定。
6、序列化的好处及应用场景
序列化会将内存中对象的状态转换成二进制文件保存到磁盘当中，当再次使用时会从磁盘中读取该二进制文件，将 Java 对象的状态恢复到内存中。
当你想把内存中的对象保存到磁盘文件或数据库中时可以使用序列化。
当你想在网络传输中传送 Java 对象时，可以使用序列化。
当你想通过 RMI 传输对象时，可以使用序列化。
7、序列化注意事项
序列化只会保存对象的属性状态，不会保存对象中的方法。
父类实现了 Serializable 接口，则其子类也自动实例化了该接口，也就是说子类不用显式实现 Serializable 接口也能参与序列化和反序列化。
一个对象 A 的实例变量引用了其他对象 B，在 A 对象实例化的过程中 ，也会序列化 B ，前提是 A、B 两个类都实现了 Serializable 接口。
当一个类实现 Serializable 接口时，最好手动指定一个序列化版本号(serialVersionUID)，避免修改源代码后导致反序列化出现异常。
当一个类对象会被多次重复使用，且一般不会对其属性做修改，就可以对其进行序列化。例如数据库操作中的实体类。


19、http如何建立连接，需要几次请求
HTTP 的长连接短连接，其实是TCP的长连接和短连接。
TCP 的连接是采用3次握手，而断开连接是采用4次握手

20、mybatis的#和$的区别
在mybatis中#和$的主要区别是：#传入的参数在SQL中显示为字符串，#方式能够很大程度防止sql注入；$传入的参数在SqL中直接显示为传入的值，$方式无法防止Sql注入.
1、传入的参数在SQL中显示不同
#传入的参数在SQL中显示为字符串（当成一个字符串），会对自动传入的数据加一个双引号。
$传入的参数在SqL中直接显示为传入的值
2、#可以防止SQL注入的风险（语句的拼接）；但$无法防止Sql注入。
3、$方式一般用于传入数据库对象，例如传入表名。
4、大多数情况下还是经常使用#，一般能用#的就别用$；但有些情况下必须使用$，例：MyBatis排序时使用order by 动态参数时需要注意，用$而不是#。


21、nio和bio的区别
BIO是阻塞的，NIO是非阻塞的


sql注入
1、参数校验
2、mybatis采用#{}
3、采用jdbc对象设值


消息队列


bean生命周期


springboot启动过程：



抽象类和接口的对比
抽象类用于捕捉子类的通用特性，接口是抽象方法的集合。


值传递：传递的是值得拷贝
java语言的方法调用只支持参数的值传递


Integer a=127和 Integer b=127相等吗
基本数据类型，==比较的是值
引用数据类型，==比较的是地址
如果整形字面量在-128到127之间，自动装箱不会new新的Integer对象，而是引用常量池中的Integer对象，==是true
超过范围则为false


aop



ioc
Ioc容器来控制对象的创建
控制反转：在我们原先的对象中有用到其他对象的地方Spring会帮我们来注入


循环依赖


java创建对象的方式：
1、new
2、newInstance，运用反射创建对象时最常用的方法。Class类的newInstance使用的是类的public的无参构造器。获取 Class 对象的构造器对象，通过调用 Class 类的实例方法 getDeclaredConstractors() 来获取构造器对象的数组。
3、使用 clone() 方法，必须先实现Cloneable接口并复写Object的clone方法
4、使用反序列化的 readObject() 方法


string，stringbuffer，stringbuilder的区别：
1.基本区别
String的对象不可变，StringBuffer和StringBuilder的对象是可变的
2.性能区别
三者中StringBuilder执行速度最佳，StringBuffer次之，String的执行速度最慢（String为字符串常量，而StringBuilder和StringBuffer均为字符串变量，String对象一旦创建后该对象是不可更改的，后两者的对象是变量是可以更改的）
3.安全区别
String、StringBuffer是线程安全的，StringBuilder是线程不安全的（所以如果程序是单线程的使用StringBuilder效率高，如果是多线程使用StringBuffer或者String）
这三者的相同
1.三者在java中都是用来处理字符串的
2.三个类都被final修饰，因此都是不可继承的
3.StringBuilder与StringBuffer有公共父类AbstractStringBuilder(抽象类)

