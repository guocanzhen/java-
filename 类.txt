类：

类的生命周期：
加载、链接、初始化、使用、卸载
链接：验证、准备、解析
1、加载：将java类的字节码文件加载到机器内存中，并在内存中构建出java类的原型（类模板对象）
a、加载类时，java虚拟机加载步骤
（1）通过类的全名，获取类的二进制数据流
（2）解析类的二进制数据流为方法区内的数据结构（Java类模型）
（3）创建java.lang.Class类的实例，作为方法区这个类的各种数据的访问入口
b、类模型和Class实例的位置
（1）类模型存储在方法区
（2）class文件加载到元空间后，会在堆中创建一个Class对象，用来封装类位于方法区内的数据结构。每一个类都对应一个Class对象
c、数组类的加载
数组类本身并不是由类加载器负责创建，而是由jvm在运行时根据需要直接创建的，但是数组的元素类型仍然需要依靠类加载器去创建。创建步骤如下
（1）如果数组的元素类型是引用类型，那么遵循定义的加载过程递归加载和创建数组A的元素类型
（2）jvm使用指定的元素类型和数组维度类创建新的数组类。
2、验证
保证加载的字节码是合法的。
验证通过之后类加载器才会将类的二进制数据加载到方法区中，除格式验证之外的验证操作是在方法区中进行
（1）格式验证
（2）语义检查
（3）字节码验证
（4）符号引用验证
3、准备
当一个类通过验证，就会进入准备阶段，为静态变量分配内存，并初始化默认值。
java不支持boolean类型，内部实现是int，由于int默认值为0，所以boolean的默认值为false.
4、解析
将接口，字段和方法的符号引用转换为直接引用。
java虚拟机为每一个类都准备一张方法表，将其所有的方法列在其中，当需要调用一个类的方法时，只要知道这个方法在方法表的偏移量（通过解析操作，符号引用转换为直接引用类中的方法表中的位置），就可以直接调用该方法了。
不过java虚拟机规范并没有明确要求解析阶段一定要按序执行，在hotspot中，按照加载，验证，准备和初始化的顺序执行，但链接阶段的解析操作往往伴随着jvm执行完初始化之后再执行。
4、初始化
类的初始化是类装载的最后一个阶段，也是真正开始执行类定义的java的程序代码<clinit>()方法
在加载一个类之前会先加载其父类，因此父类的<clinit>方法总是在子类<clinit>方法之前被调用。
（1）使用static+final修饰，且显示赋值中不涉及到方法或者构造器调用的基本数据类型或者String类型的显示赋值，是在链接阶段的准备环节进行赋值。
（2）<clinit>线程安全性
5、使用
6、卸载
如果有下面的情况，类就会被卸载：
（1）该类所有的实例都已经被回收，也就是java堆中不存在该类的任何实例。
（2）加载该类的ClassLoader已经被回收。
（3）该类对应的java.lang.Class对象没有任何地方被引用，无法在任何地方通过反射访问该类的方法。
如果以上三个条件全部满足，jvm就会在方法区垃圾回收的时候对类进行卸载，类的卸载过程其实就是在方法区中清空类信息，java类的整个生命周期就结束了。


对象的生命周期：
1、创建阶段：
为对象分配存储空间，构造对象
2、应用阶段：
对象至少被一个强引用持有着。
3、不可见阶段：
当一个对象处于不可见阶段时，说明程序本身不再持有该对象的不论什么强引用，尽管该这些引用仍然是存在着的。
简单说就是程序的运行已经超出了该对象的作用域了。
4、不可达阶段：
对象处于不可达阶段是指该对象不再被不论什么强引用所持有。
5、收集阶段：
当垃圾回收器发现该对象已经处于“不可达阶段”而且垃圾回收器已经对该对象的内存空间又一次分配做好准备时，则对象进入了“收集阶段”。假设该对象已经重写了finalize()方法，则会去运行该方法的终端操作。
这里要特别说明一下：不要重载finalize()方法！原因有两点：
会影响JVM的对象分配与回收速度
在分配该对象时，JVM须要在垃圾回收器上注冊该对象，以便在回收时可以运行该重载方法；在该方法的运行时须要消耗CPU时间且在运行完该方法后才会又一次运行回收操作，即至少须要垃圾回收器对该对象运行两次GC。
可能造成该对象的再次“复活”
6、终结阶段：
当对象运行完finalize()方法后仍然处于不可达状态时，则该对象进入终结阶段。在该阶段是等待垃圾回收器对该对象空间进行回收。
7、对象空间又一次分配阶段（释放阶段）
垃圾回收器对该对象的所占用的内存空间进行回收或者再分配了，则该对象彻底消失了，称之为“对象空间又一次分配阶段”。


bean的生命周期：
1、简单说说IoC和Bean
IoC，控制反转，想必大家都知道，所谓的控制反转，就是把new对象的权利交给容器，所有的对象都被容器控制，这就叫所谓的控制反转。
Bean，也不是什么新鲜玩意儿，它们就是一帮身不由己的Java对象，生命周期受到容器控制。
2、Bean生命周期和人生
1）Bean生命周期四大阶段
我们知道，bean的作用域有好几种，这篇文章只讨论完全被IoC容器控制的单例Bean。

对于普通的Java对象来说，它们的生命周期就是：
实例化
对象不再被使用时通过垃圾回收机制进行回收
这就像是生活在大自然里的动物，悄然出生，悄然死亡。

而对于Spring Bean的生命周期来说，可以分为四个阶段，其中初始化完成之后，就代表这个Bean可以使用了：
实例化 Instantiation
属性赋值 Populate
初始化 Initialization
销毁 Destruction

Bean实例化的时机也分为两种，BeanFactory管理的Bean是在使用到Bean的时候才会实例化Bean，ApplicantContext管理的Bean在容器初始化的时候就回完成Bean实例化。

2）Bean详细生命周期
我们讲到了Bean容器四个阶段，会有一些容器级的方法，进行前置和后置的处理，比如InstantiationAwareBeanPostProcessor、BeanPostProcessor接口方法。这些方法独立于Bean之外，并且会注册到Spring容器中，在Spring容器创建Bean的时候，进行一些处理。

https://www.processon.com/diagraming/631a9ff563768972feea9ff7
实例化：第 1 步，实例化一个 Bean 对象
属性赋值：第 2 步，为 Bean 设置相关属性和依赖
初始化：初始化的阶段的步骤比较多，5、6步是真正的初始化，第 3、4 步为在初始化前执行，第 7 步在初始化后执行，初始化完成之后，Bean就可以被使用了
销毁：第 8~10步，第8步其实也可以算到销毁阶段，但不是真正意义上的销毁，而是先在使用前注册了销毁的相关调用接口，为了后面第9、10步真正销毁 Bean 时再执行相应的方法








