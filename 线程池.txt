线程池：

线程池，参数及其作用
1、核心线程数：线程池中会维护一个最小的线程数量，即使这些线程处理空闲状态，他们也不会被销毁，除非设置了allowCoreThreadTimeOut。这里的最小线程数量即是corePoolSize。任务提交到线程池后，首先会检查当前线程数是否达到了corePoolSize，如果没有达到的话，则会创建一个新线程来处理这个任务。
2、最大线程数：当前线程数达到corePoolSize后，如果继续有任务被提交到线程池，会将任务缓存到工作队列（后面会介绍）中。如果队列也已满，则会去创建一个新线程来出来这个处理。线程池不会无限制的去创建新线程，它会有一个最大线程数量的限制，这个数量即由maximunPoolSize指定。
3、工作队列、队列大小：新任务被提交后，会先进入到此工作队列中，任务调度时再从队列中取出任务。
①ArrayBlockingQueue：基于数组的有界阻塞队列，按FIFO排序。新任务进来后，会放到该队列的队尾，有界的数组可以防止资源耗尽问题。当线程池中线程数量达到corePoolSize后，再有新任务进来，则会将任务放入该队列的队尾，等待被调度。如果队列已经是满的，则创建一个新线程，如果线程数量已经达到maxPoolSize，则会执行拒绝策略。
②LinkedBlockingQuene：基于链表的无界阻塞队列（其实最大容量为Interger.MAX），按照FIFO排序。由于该队列的近似无界性，当线程池中线程数量达到corePoolSize后，再有新任务进来，会一直存入该队列，而基本不会去创建新线程直到maxPoolSize（很难达到Interger.MAX这个数），因此使用该工作队列时，参数maxPoolSize其实是不起作用的。
③SynchronousQuene：一个不缓存任务的阻塞队列，生产者放入一个任务必须等到消费者取出这个任务。也就是说新任务进来时，不会缓存，而是直接被调度执行该任务，如果没有可用线程，则创建新线程，如果线程数量达到maxPoolSize，则执行拒绝策略。
④PriorityBlockingQueue：具有优先级的无界阻塞队列，优先级通过参数Comparator实现。
4、空闲线程活跃时间：一个线程如果处于空闲状态，并且当前的线程数量大于corePoolSize，那么在指定时间后，这个空闲线程会被销毁，这里的指定时间由keepAliveTime来设定
5、空闲线程活跃时间单位
6、默认线程名称、线程工厂
7、拒绝策略
丢弃策略DiscardPolicy：对新的任务不做任何处理，翻译过来就是丢弃策略，业务中慎用。
中止策略AbortPolicy：抛出了RejectedExecutionException异常，会对代码的运行进行中止，默认拒绝策略，不执行新任务抛出异常
优先处理策略CallerRunsPolicy：把新任务交给主线程来执行，对新的任务进行优先执行，直接调用其run方法
丢弃最老任务DiscardOldestPolicy：拿到队列，调用队列的poll方法对队列中最老的任务进行丢弃，再将新的任务放入队列中
自定义拒绝策略：重写rejectedExecution方法，可以写到日志里面，也可以存储到数据库 ，也可以啥也不做
