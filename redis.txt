redis:

1、数据类型：
常用数据类型：string、hash、list、set、zset

2、IO多路复用
Redis的底层是一个单线程模型，Redis为了充分利用单线程，加快服务器的处理速度，它采用IO多路复用模型来处理客户端与服务端的连接。
这种模型有三种实现方式，分别是 select、poll、epoll。Redis 正是采用 epoll 的方式来监控多个 IO 事件。当客户端空闲时，线程处于阻塞状态；当一个或多个 IO 事件触发时（客户端发起网路连接请求），线程就会从阻塞状态唤醒，并同时使用epoll来轮询触发事件，并依次提交给线程处理。

3、Redis Stream消息队列

4、Redis布隆过滤器（去重）
相比于 Set 集合的去重功能而言，布隆过滤器在空间上能节省 90% 以上，但是它的不足之处是去重率大约在 99% 左右，也就是说有 1% 左右的误判率
布隆过滤器使用exists()来判断某个元素是否存在于自身结构中。当布隆过滤器判定某个值存在时，其实这个值只是有可能存在；当它说某个值不存在时，那这个值肯定不存在，这个误判概率大约在 1% 左右。

5、Redis Benchmark性能测试

6、Redis分区技术
Redis 分区技术（又称 Redis Partition）指的是将 Redis 中的数据进行拆分，然后把拆分后的数据分散到多个不同的 Redis 实例（即服务器）中，每个实例仅存储数据集的某一部分（一个子集），我们把这个过程称之为 Redis 分区操作。
Redis 分区技术有两个方面的优势，一是提升服务器的性能，二是提高了服务器的数据存储能力。
分区技术有两种常用方法，分别是“范围分区”和“哈希分区”。

7、Redis Pipeline管道技术（只能linux执行，windows缺少nc命令）
使用该技术可以一次性向服务器发送多条命令，并返回多个执行结果。这样就节省了发送命令和创建连接的时间，从而提高了执行效率。

8、Redis数据备份和还原
Redis SAVE 命令用于创建当前数据库的备份文件，文件名默认为dump.rdb。

9、Redis RDB持久化（快照（snapshot）模式）

RDB快照模式原理
所谓“快照”就是将内存数据以二进制文件的形式保存起来。
Redis 使用操作系统的多进程 COW(Copy On Write) 机制来实现快照持久化操作。
RDB实际上是Redis内部的一个定时器事件，它每隔一段固定时间就去检查当前数据发生改变的次数和改变的时间频率，看它们是否满足配置文件中规定的持久化触发条件。当满足条件时，Redis 就会通过操作系统调用 fork() 来创建一个子进程，该子进程与父进程享有相同的地址空间。
Redis 通过子进程遍历整个内存空间来获取存储的数据，从而完成数据持久化操作。注意，此时的主进程则仍然可以对外提供服务，父子进程之间通过操作系统的 COW 机制实现了数据段分离，从而保证了父子进程之间互不影响。

RDB持久化触发策略

手动触发策略：通过SAVAE命令或者BGSAVE命令将内存数据保存到磁盘文件中
1、SAVE命令会阻塞Redis服务器进程，直到dump.rdb文件创建完毕为止，在这个过程中，服务器不能处理任何的命令请求。
2、BGSAVE命令是非阻塞式的，所谓非阻塞式，指的是在该命令执行的过程中，并不影响Redis服务器处理客户端的其他请求。这是因为Redis服务器会fork()一个子进程来进行持久化操作（比如创建新的dunp.rdb文件），而父进程则继续处理客户端请求。当子进程处理完后会向父进程发送一个信号，通知它已经处理完毕。此时，父进程会用新的 dump.rdb 文件覆盖掉原来的旧文件。
3、LASTSAVE 命令用于查看 BGSAVE 命令是否执行成功。

自动触发策略：自动触发策略，是指 Redis 在指定的时间内，数据发生了多少次变化时，会自动执行BGSAVE命令。
自动触发的条件包含在了 Redis 的配置文件中
配置文件中：save m n 的含义是在时间 m 秒内，如果 Redis 数据至少发生了 n 次变化，那么就自动执行BGSAVE命令。配置策略说明如下：
save 900 1 表示在 900 秒内，至少更新了 1 条数据，Redis 自动触发 BGSAVE 命令，将数据保存到硬盘。
save 300 10 表示在 300 秒内，至少更新了 10 条数据，Redis 自动触 BGSAVE 命令，将数据保存到硬盘。
save 60 10000 表示 60 秒内，至少更新了 10000 条数据，Redis 自动触发 BGSAVE 命令，将数据保存到硬盘。
只要上述三个条件任意满足一个，服务器就会自动执行BGSAVE命令。当然您可以根据实际情况自己调整触发策略。
注意：每次创建 RDB 文件之后，Redis 服务器为实现自动持久化而设置的时间计数和次数计数就会被清零，并重新开始计数，因此多个策略的效果不会叠加。

RDB持久化优劣势
在 RDB 持久化的过程中，子进程会把 Redis 的所有数据都保存到新建的 dump.rdb 文件中，这是一个既消耗资源又浪费时间的操作。因此 Redis 服务器不能过于频繁地创建 rdb 文件，否则会严重影响服务器的性能。
RDB 持久化的最大不足之处在于，最后一次持久化的数据可能会出现丢失的情况。
RDB 数据持久化适合于大规模的数据恢复，并且还原速度快

10、Redis AOF持久化

AOF 被称为追加模式，或日志模式，是 Redis 提供的另一种持久化策略，它能够存储 Redis 服务器已经执行过的的命令，并且只记录对内存有过修改的命令，这种数据记录方法，被叫做“增量复制”，其默认存储文件为appendonly.aof。

AOF持久化机制：
每当有一个修改数据库的命令被执行时，服务器就将命令写入到 appendonly.aof 文件中，该文件存储了服务器执行过的所有修改命令，因此，只要服务器重新执行一次 .aof 文件，就可以实现还原数据的目的，这个过程被形象地称之为“命令重演”。
1、写入机制
Redis在收到客户端修改命令后，先进行相应的校验，如果没问题，就立即将该命令存追加到.aof文件中，也就是先存到磁盘中，然后服务器再执行命令。这样就算遇到了突发的宕机情况情况，也只需将存储到  .aof 文件中的命令，进行一次“命令重演”就可以恢复到宕机前的状态。
在上述执行过程中，有一个很重要的环节就是命令的写入，这是一个IO操作。Redis为了提升写入效率，它不会将内容直接写入到磁盘中，而是将其放到一个内存缓存区 （buffer）中，等到缓存区被填满时才真正将缓存区中的内容写入到磁盘里。
2、重写机制
Redis 在长期运行的过程中，aof 文件会越变越长。如果机器宕机重启，“重演”整个 aof 文件会非常耗时，导致长时间 Redis 无法对外提供服务。因此就需要对 aof 文件做一下“瘦身”运动。
为了让 aof 文件的大小控制在合理的范围内，Redis 提供了 AOF 重写机制，手动执行BGREWRITEAOF命令，开始重写 aof 文件。
通过上述操作后，服务器会生成一个新的 aof 文件，该文件具有以下特点：
新的 aof 文件记录的数据库数据和原 aof 文件记录的数据库数据完全一致；
新的 aof 文件会使用尽可能少的命令来记录数据库数据，因此新的 aof 文件的体积会小很多；
AOF 重写期间，服务器不会被阻塞，它可以正常处理客户端发送的命令。
3、自动触发AOF重写
Redis 为自动触发 AOF 重写功能，提供了相应的配置策略。如下所示：修改 Redis 配置文件，让服务器自动执行 BGREWRITEAOF 命令。
#默认配置项
auto-aof-rewrite-percentage 100
auto-aof-rewrite-min-size 64mb #表示触发AOF重写的最小文件体积,大于或等于64MB自动触发。

AOF策略配置
在上述介绍写入机制的过程中，如果遇到宕机前，缓存内的数据未能写入到磁盘中，那么数据仍然会有丢失的风险。服务器宕机时，丢失命令的数量，取决于命令被写入磁盘的时间，越早地把命令写入到磁盘中，发生意外时丢失的数据就会越少，否则越多。
redis配置文件中：appendfsync
Always：服务器每写入一个命令，就调用一次fsync函数，将缓冲区里面的命令写入到硬盘。这种模式下，服务器出现故障，也不会丢失任何已经成功执行的命令数据，但是其执行速度较慢；
Everysec（默认）：服务器每一秒调用一次fsync函数，将缓冲区里面的命令写入到硬盘。这种模式下，服务器出现故障，最多只丢失一秒钟内的执行的命令数据，通常都使用它作为 AOF 配置策略；
No：服务器不主动调用fsync函数，由操作系统决定何时将缓冲区里面的命令写入到硬盘。这种模式下，服务器遭遇意外停机时，丢失命令的数量是不确定的，所以这种策略，不确定性较大，不安全。
由于是 fsync 是磁盘 IO 操作，所以它很慢！如果 Redis 执行一条指令就要 fsync 一次（Always），那么 Redis 高性能将严重受到影响。
在生产环境的服务器中，Redis通常是每隔1s左右执行一次fsync操作（Everysec），这样既保持了高性能，也让数据尽可能的少丢失。最后一种策略（No），让操作系统来决定何时将数据同步到磁盘，这种策略存在许多不确定性，所以不建议使用。

11、混合持久化
混合持久化同样也是通过bgrewriteaof完成的，不同的是当开启混合持久化时，fork出的子进程先将共享的内存副本全量的以RDB方式写入aof文件，然后在将aof_rewrite_buf重写缓冲区的增量命令以AOF方式写入到文件，写入完成后通知主进程更新统计信息，并将新的含有RDB格式和AOF格式的AOF文件替换旧的的AOF文件。简单的说：新的AOF文件前半段是RDB格式的全量数据后半段是AOF格式的增量数据，在redis重启的时候，加载 aof 文件进行恢复数据：先加载 rdb 内容再加载剩余的 aof。
混合持久化配置：
aof-use-rdb-preamble yes  # yes：开启，no：关闭

12、Redis Cluster主从模式
主节点负责写入数据，而从节点负责读取数据。

win下：
主节点启动（默认端口号6379）： redis-server
从节点启动连接主机点（需在redis.windows-service.conf添加masterauth 主节点密码）：redis-server --port 6300 --slaveof 127.0.0.1 6379

主从模式不足:
Redis 主从模式不具备自动容错和恢复功能，如果主节点宕机，Redis 集群将无法工作，此时需要人为干预，将从节点提升为主节点。
如果主机宕机前有一部分数据未能及时同步到从机，即使切换主机后也会造成数据不一致的问题，从而降低了系统的可用性。
因为只有一个主节点，所以其写入能力和存储能力都受到一定程度地限制。
在进行数据全量同步时，若同步的数据量较大可能会造卡顿的现象。

13、Redis集群：Sentinel哨兵模式
在Redis主从复制模式中，因为系统不具备自动恢复的功能，所以当主服务器（master）宕机后，需要手动把一台从服务器（slave）切换为主服务器。在这个过程中，不仅需要人为干预，而且还会造成一段时间内服务器处于不可用状态，同时数据安全性也得不到保障，因此主从模式的可用性较低，不适用于线上生产环境。

Sentinel 通过监控的方式获取主机的工作状态是否正常，当主机发生故障时， Sentinel 会自动进行 Failover（即故障转移），并将其监控的从机提升主服务器（master），从而保证了系统的高可用性。

哨兵模式原理
哨兵模式是一种特殊的模式，Redis 为其提供了专属的哨兵命令，它是一个独立的进程，能够独立运行。
哨兵主要有两个重要作用：
第一：哨兵节点会以每秒一次的频率对每个 Redis 节点发送PING命令，并通过 Redis 节点的回复来判断其运行状态。
第二：当哨兵监测到主服务器发生故障时，会自动在从节点中选择一台将机器，并其提升为主服务器，然后使用 PubSub 发布订阅模式，通知其他的从节点，修改配置文件，跟随新的主服务器。
在实际生产情况中，Redis Sentinel 是集群的高可用的保障，为避免Sentinel发生意外，它一般是由3～5个节点组成，这样就算挂了个别节点，该集群仍然可以正常运转。

多个哨兵之间也存在互相监控，这就形成了多哨兵模式
1) 主观下线
主观下线，适用于主服务器和从服务器。如果在规定的时间内(配置参数：down-after-milliseconds)，Sentinel节点没有收到目标服务器的有效回复，则判定该服务器为“主观下线”。比如 Sentinel 向主服务发送了PING命令，在规定时间内没收到主服务器PONG回复，则 Sentinel1 判定主服务器为“主观下线”。
2) 客观下线
客观下线，只适用于主服务器。 Sentinel 发现主服务器出现了故障，它会通过相应的命令，询问其它 Sentinel 节点对主服务器的状态判断。如果超过半数以上的  Sentinel 节点认为主服务器 down 掉，则 Sentinel1 节点判定主服务为“客观下线”。
3) 投票选举
投票选举，所有Sentinel节点会通过投票机制，按照谁发现谁去处理的原则，选举Sentinel为领头节点去做Failover（故障转移）操作。Sentinel节点则按照一定的规则在所有从节点中选择一个最优的作为主服务器，然后通过发布订功能通知其余的从节点（slave）更改配置文件，跟随新上任的主服务器（master）。至此就完成了主从切换的操作。
Sentinel负责监控主从节点的“健康”状态。当主节点挂掉时，自动选择一个最优的从节点切换为主节点。客户端来连接Redis集群时，会首先连接Sentinel，通过Sentinel 来查询主节点的地址，然后再去连接主节点进行数据交互。当主节点发生故障时，客户端会重新向Sentinel要地址，Sentinel会将最新的主节点地址告诉客户端。因此应用程序无需重启即可自动完成主从节点切换。

哨兵模式应用
配置sentinel哨兵
首先新建 sentinel.conf 文件，并对其进行配置，如下所示:
port 26379
Sentinel monitor biancheng 127.0.0.1 6379 1
配置文件说明如下：
port 26379 #sentinel监听端口，默认是26379，可以更改
sentinel monitor <master-name> <ip> <redis-port> <quorum>
第二个配置项表示：让 sentinel 去监控一个地址为 ip:port 的主服务器，这里的 master-name 可以自定义；<quorum> 是一个数字，表示当有多少个 sentinel 认为主服务器宕机时，它才算真正的宕机掉，通常数量为半数或半数以上才会认为主机已经宕机，<quorum> 需要根据 sentinel 的数量设置。

初始配置：
# 当前Sentinel服务运行的端口
port 26381
# 哨兵监听的主服务器 后面的1表示主机挂掉以后进行投票，只需要1票就可以从机变主机
sentinel monitor mymaster 127.0.0.1 6379 1
# 3s内mymaster无响应，则认为mymaster宕机了
sentinel down-after-milliseconds mymaster 3000
#如果10秒后,mysater仍没启动过来，则启动failover
sentinel failover-timeout mymaster 10000
# 执行故障转移时， 最多有1个从服务器同时对新的主服务器进行同步
sentinel config-epoch mymaster 0
# 设置哨兵sentinel 连接主从的密码 注意必须为主从设置一样的验证密码，没有的话不用设置（小编没有设置密码）
# sentinel auth-pass mymaster 123456

启动哨兵：
redis-server sentinel.conf --sentinel
如果您想开启多个哨兵，只需配置要多个 sentinel.conf 文件即可，一个配置文件开启一个。

14、Redis分布式锁
Redis 分布式锁主要有以下特点：
第一：互斥性是分布式锁的重要特点，在任意时刻，只有一个线程能够持有锁；
第二：锁的超时时间，一个线程在持锁期间挂掉了而没主动释放锁，此时通过超时时间来保证该线程在超时后可以释放锁，这样其他线程才可以继续获取锁；
第三：加锁和解锁必须是由同一个线程来设置；
第四：Redis 是缓存型数据库，拥有很高的性能，因此加锁和释放锁开销较小，并且能够很轻易地实现分布式锁。

Redis分布式锁命令
Redis 分布式锁常用命令如下所示：
SETNX key val：仅当key不存在时，设置一个 key 为 value 的字符串，返回1；若 key 存在，设置失败，返回 0；
Expire key timeout：为 key 设置一个超时时间，以 second 秒为单位，超过这个时间锁会自动释放，避免死锁；
DEL key：删除 key。

上述 SETNX 命令相当于占“坑”操作，EXPIRE 是为避免出现意外用来设置锁的过期时间，也就是说到了指定的过期时间，该客户端必须让出锁，让其他客户端去持有。

直接使用 SET 命令实现，语法格式如下：
SET key value [expiration EX seconds|PX milliseconds] [NX|XX]
EX second：设置键的过期时间为 second 秒。 SET key value EX second 效果等同于 SETEX key second value 。
PX millisecond：设置键的过期时间为毫秒。SET key value PX millisecond 效果等同于 PSETEX key millisecondvalue 。
NX：只在键不存在时，才对键进行设置操作。 SET key value NX 效果等同于 SETNX key value 。
XX：只在键已经存在时，才对键进行设置操作。

15、Redis缓存问题
缓存穿透
缓存穿透是指当用户查询某个数据时，Redis中不存在该数据，也就是缓存没有命中，此时查询请求就会转向持久层数据库MySQL，结果发现MySQL中也不存在该数据，MySQL 只能返回一个空对象，代表此次查询失败。如果这种类请求非常多，或者用户利用这种请求进行恶意攻击，就会给MySQL数据库造成很大压力，甚至于崩溃，这种现象就叫缓存穿透。
为了避免缓存穿透问题，下面介绍两种解决方案：
1) 缓存空对象
当MySQL返回空对象时，Redis将该对象缓存起来，同时为其设置一个过期时间。当用户再次发起相同请求时，就会从缓存中拿到一个空对象，用户的请求被阻断在了缓存层，从而保护了后端数据库，但是这种做法也存在一些问题，虽然请求进不了 MYSQL，但是这种策略会占用 Redis 的缓存空间。
2) 布隆过滤器
我们知道，布隆过滤器判定不存在的数据，那么该数据一定不存在，利用它的这一特点可以防止缓存穿透。
首先将用户可能会访问的热点数据存储在布隆过滤器中（也称缓存预热），当有一个用户请求到来时会先经过布隆过滤器，如果请求的数据，布隆过滤器中不存在，那么该请求将直接被拒绝，否则将继续执行查询。相较于第一种方法，用布隆过滤器方法更为高效、实用。
缓存预热：是指系统启动时，提前将相关的数据加载到 Redis 缓存系统中。这样避免了用户请求的时再去加载数据。

缓存击穿
缓存击穿是指用户查询的数据缓存中不存在，但是后端数据库却存在，这种现象出现原因是一般是由缓存中key过期导致的。比如一个热点数据key，它无时无刻都在接受大量的并发访问，如果某一时刻这个 key 突然失效了，就致使大量的并发请求进入后端数据库，导致其压力瞬间增大。这种现象被称为缓存击穿。
缓存击穿有两种解决方法：
1) 改变过期时间
设置热点数据永不过期。
2) 分布式锁
采用分布式锁的方法，重新设计缓存的使用方式，过程如下：
上锁：当我们通过 key 去查询数据时，首先查询缓存，如果没有，就通过分布式锁进行加锁，第一个获取锁的进程进入后端数据库查询，并将查询结果缓到Redis 中。
解锁：当其他进程发现锁被某个进程占用时，就进入等待状态，直至解锁后，其余进程再依次访问被缓存的 key。

缓存雪崩
缓存雪崩是指缓存中大批量的key同时过期，而此时数据访问量又非常大，从而导致后端数据库压力突然暴增，甚至会挂掉，这种现象被称为缓存雪崩。它和缓存击穿不同，缓存击穿是在并发量特别大时，某一个热点 key 突然过期，而缓存雪崩则是大量的 key 同时过期，因此它们根本不是一个量级。
解决方案
缓存雪崩和缓存击穿有相似之处，所以也可以采用热点数据永不过期的方法，来减少大批量的 key 同时过期。再者就是为 key 设置随机过期时间，避免 key 集中过期。

16、redis数据结构
Redis 数据结构并不是指 String（字符串）对象、List（列表）对象、Hash（哈希）对象、Set（集合）对象和 Zset（有序集合）对象，因为这些是 Redis 键值对中值的数据类型，也就是数据的保存形式，这些对象的底层实现的方式就用到了数据结构

1）键值对数据库是怎么实现的？
Redis 的键值对中的 key 就是字符串对象，而 value 可以是字符串对象，也可以是集合数据类型的对象，比如 List 对象、Hash 对象、Set 对象和 Zset 对象。

这些键值对是如何保存在 Redis 中的呢？
Redis 是使用了一个「哈希表」保存所有键值对，哈希表的最大好处就是让我们可以用 O(1) 的时间复杂度来快速查找到键值对。哈希表其实就是一个数组，数组中的元素叫做哈希桶。

dictEntry 结构，表示哈希表节点的结构，结构里存放了 **void * key 和 void * value 指针， key 指向的是 String 对象，而 value 则可以指向 String 对象，也可以指向集合类型的对象，比如 List 对象、Hash 对象、Set 对象和 Zset 对象。
特别说明下，void * key 和 void * value 指针指向的是 Redis 对象，Redis 中的每个对象都由 redisObject 结构表示

2）SDS
Redis 是用 C 语言实现的，但是它没有直接使用 C 语言的 char* 字符数组来实现字符串，而是自己封装了一个名为简单动态字符串（simple dynamic string，SDS） 的数据结构来表示字符串，也就是 Redis 的 String 数据类型的底层数据结构是 SDS。
既然 Redis 设计了 SDS 结构来表示字符串，肯定是 C 语言的 char* 字符数组存在一些缺陷。

C 语言字符串的缺陷
C 语言的字符串其实就是一个字符数组，即数组中每个元素是字符串中的一个字符。
1.获取字符串长度的时间复杂度为 O（N）；
2.字符串的结尾是以 “\0” 字符标识，字符串里面不能包含有 “\0” 字符，因此不能保存二进制数据；
3.字符串操作函数不高效且不安全，比如有缓冲区溢出的风险，有可能会造成程序运行终止；

SDS 结构设计
Redis 的 SDS 结构在原本字符数组之上，增加了三个元数据：len、alloc、flags，用来解决 C 语言字符串的缺陷。
结构中的每个成员变量分别介绍下：
len，记录了字符串长度。这样获取字符串长度的时候，只需要返回这个成员变量值就行，时间复杂度只需要 O（1）。
alloc，分配给字符数组的空间长度。这样在修改字符串的时候，可以通过alloc-len计算出剩余的空间大小，可以用来判断空间是否满足修改需求，如果不满足的话，就会自动将 SDS的空间扩展至执行修改所需的大小，然后才执行实际的修改操作，所以使用 SDS 既不需要手动修改 SDS的空间大小，也不会出现前面所说的缓冲区溢出的问题。
flags，用来表示不同类型的 SDS。一共设计了 5 种类型，分别是 sdshdr5、sdshdr8、sdshdr16、sdshdr32 和 sdshdr64，后面在说明区别之处。
buf[]，字符数组，用来保存实际数据。不仅可以保存字符串，也可以保存二进制数据。

3）链表
4）压缩列表
5）哈希表
6）整数集合
7）跳表
8）quicklist
9）listpack

17、Redis 事务操作
提到redis的事务，相信很多初学的朋友会对它的理解和使用有些模糊不清，料想它和我们常见的关系型数据库（mysql 、mssql等）中的事务相同，也支持回滚，但这样理解就进入了一个误区，首先：关系型数据中的事务都是原子性的，而redis 的事务是非原子性的。

Redis事务相关命令：

MULTI ：开启事务，redis会将后续的命令逐个放入队列中，然后使用EXEC命令来原子化执行这个命令系列。
多数事务失败是由语法错误或者数据结构类型错误导致的，语法错误说明在命令入队前就进行检测的，而类型错误是在执行时检测的，Redis为提升性能而采用这种简单的事务，这是不同于关系型数据库的，特别要注意区分。

EXEC：执行事务中的所有操作命令。
必须与MULTI命令成对使用

DISCARD：取消事务，放弃执行事务块中的所有命令。

WATCH：监视一个或多个key,如果事务在执行前，这个key(或多个key)被其他命令修改，则事务被中断，不会执行事务中的任何命令。
严格的说Redis的命令是原子性的，而事务是非原子性的，我们要让Redis事务完全具有事务回滚的能力，需要借助于命令WATCH来实现。
Redis使用WATCH命令来决定事务是继续执行还是回滚，那就需要在MULTI之前使用WATCH来监控某些键值对，然后使用MULTI命令来开启事务，执行对数据结构操作的各种命令，此时这些命令入队列。
当使用EXEC执行事务时，首先会比对WATCH所监控的键值对，如果没发生改变，它会执行事务队列中的命令，提交事务；如果发生变化，将不会执行事务中的任何命令，同时事务回滚。
当然无论是否回滚，Redis都会取消执行事务前的WATCH命令。

UNWATCH：取消WATCH对所有key的监视。

18、redis做消息队列
需要提醒一下，生产环境中如果对消息的可靠性有十分高的要求（比如订单支付的消费消息），请使用专业的消息队列（例如：rmq，amq等），对消息的丢失有一定容忍度的程序完全可以使用redis，例如我们的日志收集程序。
缺陷：
消息队列的本质还是消费者和生产者的问题，只要是这样的场景，就会涉及到两端不平衡的情况，具体可表现为：
1）生产者生产速度大于消费者消费速度，面临消息不断堆积的问题，随着消息数据的堆积，队列是开启限流措施，还是丢弃某些消息，更或者是把消息数据进行持久化。对于基于redis实现的消息队列，一般为可忍受部分消息丢失的业务，所以很多人选择丢弃消息的方案。另一种方案是基于redis单线程机制，可以增加消费者数量，这也是仅仅针对消息只被消费一次的场景。当然也可以选择持久化方案，但是会对redis的性能产生影响。

2）消费者消费速度大于生产者生产速度，有的同学会说，这样挺好啊，是，在某种意义上是比反过来的那个场景要好一些，毕竟可以避免产生消息的堆积问题。但是消费者没有消息消费，会导致消费者进程一直在那里浪费cpu资源，而且还会把redis的QPS拉高。类似于这种死循环的场景，一般而且最常用的解决方案是让线程sleep 一小段时间，既降低了消费端cpu也降低了redis的QPS。但是sleep会有一个问题，会导致处理消息的延迟，例如sleep了一秒，那消息的延迟处理就有可能会延迟一秒，虽然在大部分场景下这都不是什么问题，但是作为程序员怎么能不追求极致和完美呢？
关于消息延迟的问题，最暴力简单的方式就是增加消费客户端，这样可用多消费端交错的方式来缩小延迟的间隔，当然redis的设计者也考虑了这个问题，所有有了Blpop 命令

Redis Blpop 命令移出并获取列表的第一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。
redis 127.0.0.1:6379> BLPOP LIST1 LIST2 .. LISTN TIMEOUT

而且还可以设置超时自动返回，岂不是完美。但是还要顺便一句，redis的连接在空闲一段时间后，服务端可能会主动断开，Blpop命令会抛出异常，所以还要做好了重试或者其他策略为好。

3）如果作为专业的消息队列，一个消息被多个不同的业务消费（一个消息被消费多次）是必须要支持的，但是redis是基于自己的list数据结构来实现的伪队列，所以这种业务场景下就不要考虑redis了，或者自己封装一个类似分发器的中间件也可以。

4）基于redis的消息队列没有Ack的保证，换句话说，一个消息是否被正常处理redis是不知道的，这在很大程度上限制了它的适用场景。

19、Redis的延时任务应用
1）键的过期时间

在设置缓存的时候，我们比较多情况下都会设置一个缓存的过期时间，这个时间过期后，会重新去数据源拿数据回来。

可以基于这个过期时间结合Redis的keyspace notifications共同完成。
keyspace notifications里面包含了非常多的事件，这里只关注EXPIRE，这个是和过期有关的。
只要订阅了__keyevent@0__:expired这个主题，当有key过期的时候，就会收到对应的信息。
主题@后面的0，指的是db 0.


要想使用这个特性，必不可少的一步是修改Redis默认的配置，把notify-keyspace-events设置成Ex。
############################# Event notification ##############################
 
# Redis can notify Pub/Sub clients about events happening in the key space.
# This feature is documented at http://redis.io/topics/notifications
#
# .........
#
#  By default all notifications are disabled because most users don't need
#  this feature and the feature has some overhead. Note that if you don't
#  specify at least one of K or E, no events will be delivered.
notify-keyspace-events "Ex"

其中 E 指的是键事件通知，x 指的是过期事件。

2）有序集合
有序集合是Redis中一种十分有用的数据结构，它的本质其实就是集合加了一个排序的功能，每个集合里面的元素还会有一个分值的属性。
它提供了一个可以获取指定分值范围内的元素，这个也就是我们的出发点。
在这个场景下，什么东西可能作为这个分值呢？现在只有一个处理任务的Id还有一个延迟的时间，Id肯定不行，那么也只能是延迟时间来作这个分值了。
延迟1秒，5秒，1分钟，这个都是比较大粒度的时间，这里要转化一下，用时间戳来代替这些延迟的时间。
假设现在的时间戳是 1584171520, 要延迟5秒执行，那么执行任务的时间就是 1584171525，在当前时间戳的基础上加个5秒，就是最终要执行的了。

接下来就是要怎么取出这些任务的问题了！
把当前时间戳当成是取数的最大分值，0作为最小分值，这个时候取出的元素就是应该要执行回传的任务了。

20、redis-cluster
Rediss-Cluster即Redis集群，是Redis官方在3.0版本推出的一套分布式存储方案。完全去中心化，由多个节点组成，所有节点彼此互联。Redis客户端可以直接连接任何一节点获取集群中的键值对，不需要中间代理，如果该节点不存在用户所指定的键值，其内部会自动把客户端重定向到键值所在的节点。
Redis 集群是一个网状结构，每个节点都通过 TCP 连接跟其他每个节点连接。在一个有 N 个节点的集群中，每个节点都有 N-1 个流出的 TCP 连接，和 N-1 个流入的连接，这些 TCP 连接会永久保持。

Redis Cluster 同其他分布式存储系统一样，主要具备以下两个功能：
数据分区Redis 集群会将用户数据分散保存至各个节点中，突破单机 Redis 内存最大存储容量。集群引入了 哈希槽slot的概念，其搭建完成后会生 16384 个哈希槽slot，同时会根据节点的数量大致均等的将 16384 个哈希槽映射到不同的节点上。当用户存储key-value时，集群会先对key进行 CRC16 校验然后对 16384 取模来决定key-value放置哪个槽，从而实现自动分割数据到不同的节点上。
数据冗余Redis 集群支持主从复制和故障恢复。集群使用了主从复制模型，每个主节点master应至少有一个从节点slave。假设某个主节点故障，其所有子节点会广播一个数据包给集群里的其他主节点来请求选票，一旦某个从节点收到了大多数主节点的回应，那么它就赢得了选举，被推选为主节点，负责处理之前旧的主节点负责的哈希槽。

依据 Redis Cluster 内部故障转移实现原理，Redis 集群至少需要 3 个主节点，而每个主节点至少有 1 从节点，因此搭建一个集群至少包含 6 个节点，三主三从，并且分别部署在不同机器上。

21、双写
1）先更新数据库，再删除缓存
若数据库更新成功，删除缓存操作失败，则此后读到的都是缓存中过期的数据，造成不一致问题。
2）先更新数据库，再更新缓存
同删除缓存策略一样，若数据库更新成功缓存更新失败则会造成数据不一致问题。
当两个写线程发生冲突时，可以通过比较数据版本方式避免线程A写入旧的数据。
3）先删除缓存，再更新数据库
4）先更新缓存，再更新数据库
若缓存更新成功数据库更新失败， 则此后读到的都是未持久化的数据。因为缓存中的数据是易失的，这种状态非常危险。
因为数据库因为键约束导致写入失败的可能性较高，所以这种策略风险较大。

异步更新
双写更新的逻辑复杂，一致性问题较多。现在我们可以采用订阅数据库更新的方式来更新缓存。

22、redis单线程还是多线程
Redis执行 Redis 命令的核心模块是单线程的
Redis 4.0 开始就有多线程的概念了，比如 Redis 通过多线程方式在后台删除对象、以及通过 Redis 模块实现的阻塞命令等。
网络io多线程

