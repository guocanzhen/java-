锁：

乐观锁、悲观锁（排它锁、共享锁）
同步锁
分段锁
公平锁、非公平锁

分段锁
分段锁其实是一种锁的设计，并不是具体的一种锁，对于ConcurrentHashMap而言，其并发的实现就是通过分段锁的形式来实现高效的并发操作。
当需要put元素的时候，并不是对整个hashmap进行加锁，而是先通过hashcode来知道他要放在哪一个分段中，然后对这个分段进行加锁，所以当多线程put的时候，只要不是放在一个分段中，就实现了真正的并行的插入。
分段锁的设计目的是细化锁的粒度，当操作不需要更新整个数组的时候，就仅仅针对数组中的一项进行加锁操作。

乐观锁、悲观锁
乐观锁：每次获取数据的时候，都不担心数据被修改，所以每次获取的数据的时候都不会进行加锁，但是在更新数据的时候需要判断该数据是否被别人修改过。如果数据被其他线程修改，则不进行数据更新；如果数据没有被其他线程修改，则进行数据更新。由于数据没有进行加锁，期间该数据可以被其他线程进行读写操作
比较适合读取比较频繁的场景。如果出现大量的写入操作，数据发生重复的可能性就会增大。为了保证数据的一致性，应用层会不断的重新获取数据，这样会增加大量的查询开销，降低系统的吞吐量。 cas算法
mysql ：
ABA问题:
update table set a = 2 where a = 1 --  
update table set a = 1 where a = 2 -- 
update table set a = 2 where a = 1 --
 
update table set a = a - 1 where key = 1 and a-1 >= 0 -- 乐观锁
update table set version = version + 1 where key = 1 and version = version -- 乐观锁（版本号加1或使用时间戳，避免ABA问题）

悲观锁：
java中使用synchronized关键字和lock实现类。

synchronized的介绍
synchronized是Java中的关键字，是一种同步锁、悲观锁。它修饰的对象有以下几种：
1. 修饰一个代码块，被修饰的代码块称为同步语句块，其作用的范围是大括号{}括起来的代码，作用的对象是调用这个代码块的对象；
a、一个线程访问一个对象中的synchronized(this)同步代码块时，其他试图访问该对象的线程将被阻塞。
当两个并发线程(thread1和thread2)访问同一个对象(syncThread)中的synchronized代码块时，在同一时刻只能有一个线程得到执行，另一个线程受阻塞，必须等待当前线程执行完这个代码块以后才能执行该代码块。Thread1和thread2是互斥的，因为在执行synchronized代码块时会锁定当前的对象，只有执行完该代码块才能释放该对象锁，下一个线程才能执行并锁定该对象。
synchronized锁定的是对象，这时会有两把锁分别锁定syncThread1对象和syncThread2对象，而这两把锁是互不干扰的，不形成互斥，所以两个线程可以同时执行。
b、当一个线程访问对象的一个synchronized(this)同步代码块时，另一个线程仍然可以访问该对象中的非synchronized(this)同步代码块。
一个线程访问一个对象的synchronized代码块时，别的线程可以访问该对象的非synchronized代码块而不受阻塞。
2. 修饰一个方法，被修饰的方法称为同步方法，其作用的范围是整个方法，作用的对象是调用这个方法的对象；
在用synchronized修饰方法时要注意以下几点：
synchronized关键字不能继承。 
在定义接口方法时不能使用synchronized关键字。
构造方法不能使用synchronized关键字，但可以使用synchronized代码块来进行同步。
3. 修饰一个静态的方法，其作用的范围是整个静态方法，作用的对象是这个类的所有对象；
syncThread1和syncThread2是SyncThread的两个对象，但在thread1和thread2并发执行时却保持了线程同步。这是因为run中调用了静态方法method，而静态方法是属于类的，所以syncThread1和syncThread2相当于用了同一把锁。
4. 修饰一个类，其作用的范围是synchronized后面括号括起来的部分，作用的对象是这个类的所有对象。
总结：
1、无论synchronized关键字加在方法上还是对象上，如果它作用的对象是非静态的，则它取得的锁是对象；如果synchronized作用的对象是一个静态方法或一个类，则它取得的锁是对类，该类所有的对象同一把锁。 
2、每个对象只有一个锁（lock）与之相关联，谁拿到这个锁谁就可以运行它所控制的那段代码。 
3、实现同步是要很大的系统开销作为代价的，甚至可能造成死锁，所以尽量避免无谓的同步控制

volatile的介绍
volatile具备两种特性，第一就是保证共享变量对所有线程的可见性。将一个共享变量声明为volatile后，会有以下效应：
1、当写一个volatile变量时，JMM会把该线程对应的本地内存中的变量强制刷新到主内存中去；
2、这个写操作会导致其他线程中的缓存无效。
使用场景
先说一下volatile的使用场景，你只能在有限的一些情形下使用 volatile 变量替代锁。要使 volatile 变量提供理想的线程安全，必须同时满足下面两个条件：
1、对变量的写操作不依赖于当前值。
2、该变量没有包含在具有其他变量的不变式中。
volatile最适用一个线程写，多个线程读的场合。
如果有多个线程并发写操作，仍然需要使用锁或者线程安全的容器或者原子变量来代替。

两者的区别
1、volatile是变量修饰符，而synchronized则作用于一段代码或方法。
2、volatile只是在线程内存和“主”内存间同步某个变量的值；而synchronized通过锁定和解锁某个监视器同步所有变量的值, 显然synchronized要比volatile消耗更多资源。
3、volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞。
4、volatile保证数据的可见性，但不能保证原子性；而synchronized可以保证原子性，也可以间接保证可见性，因为它会将私有内存中和公共内存中的数据做同步。
5、volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化。
线程安全包含原子性和可见性两个方面，Java的同步机制都是围绕这两个方面来确保线程安全的。
关键字volatile主要使用的场合是在多个线程中可以感知实例变量被修改，并且可以获得最新的值使用，也就是多线程读取共享变量时可以获得最新值使用。
关键字volatile提示线程每次从共享内存中读取变量，而不是私有内存中读取，这样就保证了同步数据的可见性。如上第二个栗子，可以得出volatile本身并不处理数据的原子性，而是强制对数据的读写及时的影响到主内存中。


数据库悲观锁的实现，往往依靠数据库提供的锁机制(也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系统不会修改数据)。
悲观并发控制实际上是“先取锁再访问”的保守策略，为数据处理的安全提供了保证。但是在效率方面，处理加锁的机制会让数据库产生额外的开销，还有增加产生死锁的机会。另外还会降低并行性，一个事务如果锁定了某行数据，其他事务就必须等待该事务处理完才可以处理那行数据。
mysql innodb ：
排它锁（与其他锁不能共存，其他事务就不能再获取该行的其他锁）：for update
共享锁（可以和其他锁共存，只能读不能修改）：lock in share mode