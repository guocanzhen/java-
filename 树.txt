树：

1）原理：

树的词汇：
1、节点
节点是树的基本部分，可以有附加信息。
2、边
连接两个节点显示它们之间存在的关系
3、根
树的根是树中唯一没有传入边的节点
4、路径
路径是边连接节点额有序列表
5、子节点
具有来自相同传入边的节点c的集合称为该节点的子节点
6、父节点
具有和它相同传入边的所连接的节点称为父节点
7、兄弟
树中同一父节点的节点被称为兄弟节点
8、子树
子树是由父节点和该父节点的所有后代组成的一组节点和边
9、叶节点
叶节点是没有子节点的节点
10.层数
节点n的层数为从根节点到该节点所经过的分支数目
11、高度
树的高度等于树中任何节点的最大层数

2）树的遍历：
三种遍历方式（深度优先搜索）：先序、中序、后序
先序：先访问根节点，再访问左子树，最后访问右子树。
中序：先左子树，再根节点，最后右子树。
后序：先左子树，再右子树，最后根节点。

层序遍历（广度优先搜索）：每一层从左到右访问每一个节点。

3）二叉树的详解与实现

二叉树分类
1、完全二叉树
若设二叉树的高度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第h层有叶子结点，并且叶子结点都是从左到右依次排布，这就是完全二叉树。
一维数组可以作为完全二叉树的存储结构，堆排序使用的数据结构就是完全二叉树。

2、满二叉树
国际标准定义是除了叶结点外每一个结点都有左右子结点的二叉树
国内的定义是：除了叶结点外每一个结点都有左右子叶且叶子结点都处在最底层的二叉树。很显然，按照这个定义，上面的图示二叉树就不是满二叉树。

3、扩充二叉树
扩充二叉树是对已有二叉树的扩充，扩充后的二叉树的节点都变为度数为2的分支节点。也就是说，如果原节点的度数为2，则不变，度数为1，则增加一个分支，度数为0的叶子节点则增加两个分支。

4、平衡二叉树
是一棵空树或它的任意节点的左右两个子树的高度差的绝对值不超过1

4）二叉树的应用场景

普通的二叉树，很难构成现实的应用场景，但因其简单，常用于学习研究，平衡二叉树则是实际应用比较多的。常见于快速匹配、搜索等方面。

常用的树有：AVL树、红黑树、B+树、Trie（字典）树。
1、AVL树: 最早的平衡二叉树之一。应用相对其他数据结构比较少。windows对进程地址空间的管理用到了AVL树。如果一棵二叉搜索树的高度是平衡的，它就是AVL树。（注意： 这里所说的二叉搜索树的高度是平衡的是指，树中每个结点左右子树高度之差的绝对值不超过1，因为只有满二叉树才能做到每个结点左右子树高度之差均为0。）
2、红黑树: 平衡二叉树，广泛用在C++的STL中。如map和set都是用红黑树实现的。还有Linux文件管理。
3、B/B+树: 用在磁盘文件组织、数据索引和数据库索引。
4、Trie树(字典树): 用在统计和排序大量字符串，如自动机、M数据库索引。

5）二叉排序树（BST树）
二叉排序树，又称二叉查找树、二叉搜索树。
性质如下：
若左子树不空，则左子树上所有结点的值均小于它的根结点的值；
若右子树不空，则右子树上所有结点的值均大于或等于它的根结点的值；
左、右子树也分别为二叉排序树。

6）红黑树
1、红黑树本质上是一种二叉查找树，但它在二叉查找树的基础上额外添加了一个标记（颜色），同时具有一定的规则。这些规则使红黑树保证了一种平衡，插入、删除、查找的最坏时间复杂度都为 O(logn)。
从根节点到叶节点的路径上黑色节点的个数，叫做树的黑色高度。
每个节点要么是红色，要么是黑色；/4、根节点永远是黑色的；
所有的叶节点都是是黑色的（注意这里说叶子节点其实是上图中的 NIL 节点）；
每个红色节点的两个子节点一定都是黑色；
从任一节点到其子树中每个叶子节点的路径都包含相同数量的黑色节点；
2、各种操作的时间复杂度，能保证在最坏情况下，基本的动态几何操作的时间均为O（lgn）
3、相对于BST和AVL树，红黑树是牺牲了严格的高度平衡的优越条件为代价，能够以O(log2n)的时间复杂度进行搜索、插入、删除操作。最坏情况下，查找（O(lgn)）比二叉排序树快O(n)。较于AVL树，红黑树在数据较乱时查找要更快。
4、与哈希表对比，哈希的内存需求更大，map查找log(n)级别。当数据是静态的时候使用哈希，数据需要动态维护则使用红黑树比较好。比如Linux内核系统使用红黑树维护内存块。

红黑树的旋转
左旋：把右子树里的一个节点移动到了左子树。
右旋：把左子树里的一个节点移动到了右子树。

7）线段树
线段树的提出是为了以log(n)复杂度快速的求出数组中所有树的和所提出的。
1.线段树的每个节点代表着一个区间
2.线段树具有唯一的根节点，统计的范围为：[1,N]
3.对于每个内部节点[l,r]。左子节点是[l,mid]，右边子节点是[mid+1,r]，mid = (l+r)/2（向下取整）

8）树类搜索算法
一般来说就是深度优先搜索,广度优先搜索,A搜索,IDA搜索等几种，通常用的最多就是DFS和BFS。

1、DFS简述
适用于树型查找。
找到当前可以拓展的点，就走此分支。
如果当前分支无效或者找到了目标，就退回到上一步，称之为回溯。
每个节点最多访问两次，一次入栈，一次出栈。

2、BFS简述
使用于图型结构的搜索，通过队列层层向外拓展。
找到可以拓展的点，将其放入队列中。
每次选取队列的对头，作为当前状态。

