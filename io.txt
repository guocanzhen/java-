io

1、IO模型
5种IO模型分别是：阻塞IO模型、非阻塞IO模型、IO复用模型、信号驱动的IO模型和异步IO模型。

1）什么是IO
IO在计算机中指Input/Output，也就是输入和输出。由于程序和运行时数据是在内存中驻留，由CPU这个超快的计算核心来执行，涉及到数据交换的地方，通常是磁盘、网络等，就需要IO接口。

比如打开浏览器，访问腾讯首页，浏览器这个程序就需要通过网络IO获取腾讯的网页。浏览器首先会发送数据给腾讯服务器，告诉它我想要首页的HTML，这个动作是往外发数据，叫Output，腾讯服务器把网页发过来，这个动作是从外面接收数据，叫Input。所以，通常，程序完成IO操作会有Input和Output两个数据流。当然也有只用一个的情况，比如，从磁盘读取文件到内存，就只有Input操作，反过来，把数据写到磁盘文件里，就只是一个Output操作。

I/O操作是相对于内存而言的，从外部设备进入内存就叫Input,反之从内存输出到外部设备就叫Output。LINUX中进程无法直接操作I/O设备，必须通过系统调用，请求kernel来协助完成I/O动作。内核会为每个I/O设备维护一个缓冲区。对于一个输入操作来说，进程IO系统调用后，内核会先看缓冲区中有没有相应的缓存数据，有数据则直接复制到进程空间，没有的话再到设备中读取，因为IO设备一般速度较慢，需要等待

2）IO的分类
通常用户进程中的一个完整IO分为两阶段：用户进程空间<-->内核空间、内核空间<- ->设备空间(磁盘、网络等)。IO有内存IO、 网络IO和磁盘IO三种，通常我们说的IO指的是后两者。

I/O按照设备来分的话，分为两种：一种是网络I/O，也就是通过网络进行数据的拉取和输出。一种是磁盘I/O,主要是对磁盘进行读写工作。

3）网络输入操作的两个阶段
等待网络数据到达网卡→把数据读取到内核缓冲区。
从内核缓冲区复制数据到进程空间。

4）用户空间和内核空间
虚拟内存被操作系统划分成两块：内核空间和用户空间。为了安全，它们是隔离的，即使用户的程序崩溃了，内核也不受影响。

内核空间是内核代码运行的地方，用户空间是用户程序代码运行的地方。
当进程运行在内核空间时就处于内核态，当进程运行在用户空间时就处于用户态。

5）同步和异步
由于CPU和内存的速度远远高于外设的速度，所以在IO编程中，就存在速度严重不匹配的问题。

同步请求：A调用B，B的处理是同步的，在处理完之前他不会通知A，只有处理完之后才会明确的通知A。
异步请求：A调用B，B的处理是异步的，B在接到请求后先告诉A我已经接到请求了，然后异步去处理，处理完之后通过回调等方式再通知A。
同步和异步最大的区别就是被调用方的执行方式和返回时机。同步指的是被调用方做完事情之后再返回，异步指的是被调用方先返回，然后再做事情，做完之后再想办法通知调用方。

6）阻塞和非阻塞

阻塞请求：A调用B，A一直等着B的返回，别的事情什么也不干。
非阻塞请求：A调用B，A不用一直等着B的返回，先去忙别的事情了。
阻塞和非阻塞最大的区别就是在被调用方返回结果之前的这段时间内，调用方是否一直等待。阻塞指的是调用方一直等待别的事情什么都不做。非阻塞指的是调用方先去忙别的事情。


2、I/O 是分为两个过程的：
数据准备的过程
数据从内核空间拷贝到用户进程缓冲区的过程

根据上面两个步骤的不同，IO操作可以进一步细分为下面五种：
阻塞IO模型
非阻塞IO模型
IO复用模型
信号驱动IO模型
异步IO模型

1）阻塞IO模型
进程发起IO系统调用后，进程被阻塞，转到内核空间处理，整个IO处理完毕后返回进程，操作成功则进程获取到数据。

2）非阻塞IO模型
和上面的阻塞IO模型相比，非阻塞IO模型在内核数据没准备好，需要进程阻塞的时候，就返回一个错误，以使得进程不被阻塞。
进程发起IO系统调用后，如果内核缓冲区没有数据，需要到IO设备中读取，进程返回一个错误而不会被阻塞。
进程发起IO系统调用后，如果内核缓冲区有数据，内核就会把数据返回进程。
这种工作方式下需要不断轮询查看状态。

3）IO复用模型
多个的进程的IO可以注册到一个复用器(select)上，然后用一个进程调用该select,，select会监听所有注册进来的IO。
如果select监听的IO在内核缓冲区都没有可读数据，select调用进程会被阻塞；而当任一IO在内核缓冲区中有可读数据时，select调用就会返回；而后select调用进程可以自己或通知另外的进程(注册进程)来再次发起读取IO，读取内核中准备好的数据。

Linux中IO复用的实现方式主要有Select，Poll和Epoll：
Select：注册IO、阻塞扫描，监听的IO最大连接数不能多于FD_ SIZE（1024）。
Poll：原理和Select相似，没有数量限制，但IO数量大，扫描性能线性下降。
Epoll ：事件驱动不阻塞，mmap实现内核与用户空间的消息传递，数量很大，Linux2.6后内核支持。

4）信号驱动IO模型
当进程发起一个IO操作，会向内核注册一个信号处理函数，然后进程返回不阻塞；当内核数据就绪时会发送一个信号给进程，进程便在信号处理函数中调用IO读取数据。

5）异步IO模型
当进程发起一个IO操作，进程返回(不阻塞)，但也不能返回结果。内核把整个IO处理完后，会通知进程结果，如果IO操作成功则进程直接获取到数据。

注意：
此模型和前面模型最大的区别是：前4个从内核空间拷贝数据这一过程是阻塞的，需要自己把准备好的数据，放到用户空间。
而全异步不同，异步IO是「内核数据准备好」和「数据从内核态拷贝到用户态」这两个过程都不用等待。
用户线程完全不需要关心实际的整个IO操作是如何进行的，只需要先发起一个请求，当接收内核返回的成功信号时表示IO操作已经完成，可以直接去使用数据，它是最理想的模型。

3、5种IO模型的区别
https://www.processon.com/diagraming/6317fedf7d9c0833ec7f47a3

4、同步IO与异步IO性能上的比较
1）同步IO会阻塞当前的调用线程，而异步IO则允许发起IO请求的调用线程继续执行，等到IO请求被处理后，会通知调用线程。

对于异步的IO请求，其最大的好处是：慢速的IO请求相对于应用程序而言是异步执行，这样可以极大提高应用程序的处理吞吐量。
发起IO请求的应用程序需要关心的是IO执行完成的结果，而不必忙等IO请求执行的过程。它只需要提交一个IO操作，当内核执行这个IO操作时，线程可以去运行其他逻辑，也不需要定期去查看IO是否完成，当内核完成这个IO操作后会以某种方式通知应用。
此时应用的运行和IO执行变成了并行的关系，可以批量的进行IO操作，让设备的能力得到最大发挥   

2）在“发出IO请求”到收到“IO完成”的这段时间里，同步IO模型下，主线程只能挂起，但异步IO模型下，主线程并没有休息，而是续处理其他消息。这样，在异步IO模型下，一个线程就可以同时处理多个IO请求，并且没有切换线程的操作。对于大多数IO密集型的应用程序，使用异步IO将大大提升系统的多任务处理能力。

同步的执行效率会比较低，耗费时间，但有利于我们对流程进行控制，避免很多不可掌控的意外情况；
异步的执行效率高，节省时间，但是会占用更多的资源，也不利于我们对进程进行控制

3）同步IO的优点 ：
同步流程对结果处理通常更为简单，可以就近处理。
同步流程对结果的处理始终和前文保持在一个上下文内。
同步流程可以很容易捕获、处理异常。
同步流程是最天然的控制过程顺序执行的方式。

4）异步IO的优点
异步流程可以立即给调用方返回初步的结果。
异步流程可以延迟给调用方最终的结果数据，在此期间可以做更多额外的工作，例如结果记录等等。
异步流程在执行的过程中，可以释放占用的线程等资源，避免阻塞，等到结果产生再重新获取线程处理。
异步流程可以等多次调用的结果出来后，再统一返回一次结果集合，提高响应效率。

5）异步IO使用场景
不涉及共享资源，或对共享资源只读，即非互斥操作
没有时序上的严格关系
不需要原子操作，或可以通过其他方式控制原子性
常用于IO操作等耗时操作，因为比较影响客户体验和使用性能
不影响主线程逻辑 


5、nio和bio的区别：
BIO是阻塞的，NIO是非阻塞的

1）BIO基本介绍
BIO是传统的Java IO编程，其基本的类和接口在java.io包中
BIO(blocking I/O)：同步阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销
BIO方式使用于连接数目比较小且固定的架构，这种服务方式对服务器资源要求比价高，并且局限于应用中，JDK1.4以前的唯一选择，程序简单易理解

2）NIO基本介绍
NIO全称 java non-blocking IO。从JDK 1.4开始，java提供了一些列改进的输入/输出（I/O）的新特性，被称为NIO，是同步非阻塞的
NIO相关类都被放在java.nio包及其子包下
NIO三大核心部分：Channel（通道），Buffer（缓冲区），Selector（选择器）
NIO是面向缓冲区的，或者面向块编程的。数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区内前后移动，这就增加了处理过程中的灵活性，使用它可以提供非阻塞的高伸缩性网络
JavaNIO的非阻塞模式，使一个线程从某通道发送或者读取数据，但是它仅能得到目前可用的数据，如果目前没有可用的数据时，就什么都不会获取，而不是保持线程阻塞，所以直至数据变的可读取之前，该线程可以继续做其他事情。非阻塞就是如此，一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情
通俗来讲：NIO是可以做到用一个线程处理多个操作的。假设有10000个请求过来，根据实际情况，可以分配50或100个线程来处理。不想BIO一样需要分配10000个线程来处理
其中Selector（选择器）的作用是循环监听多个客户端连接通道，如果通道中没有数据即客户端没有请求时它可以去处理别的通道或者做其他的事情，如果通道中有数据他就会选择这个通道然后进行处理，这就做到了一个线程处理多个连接。

3）BIO和NIO的区别
BIO以流的方式处理数据，NIO以块的方式处理数据，块IO的效率比流IO高很多。（比如说流IO他是一个流，你必须时刻去接着他，不然一些流就会丢失造成数据丢失，所以处理这个请求的线程就阻塞了他无法去处理别的请求，他必须时刻盯着这个请求防止数据丢失。而块IO就不一样了，线程可以等他的数据全部写入到缓冲区中形成一个数据块然后再去处理他，在这期间该线程可以去处理其他请求）
BIO是阻塞的，NIO是非阻塞的
BIO基于字节流和字符流进行操作的，而NIO基于Channel（通道）和Buffer（缓冲区）进行操作的，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。Selector（选择器）用于监听多个通道事件，因此使用单个线程就可以监听多个客户端通道




